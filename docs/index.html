<!DOCTYPE html>
<html>
<head>
    <title>Substrate Offchain Worker Example</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><style>/*--------------------- Layout and Typography ----------------------------*/
body {
    font-family: 'Source Serif Pro', 'Book Antiqua', Palatino, FreeSerif, serif;
    font-size: 10px;
    line-height: 22px;
    color: #252519;
    margin: 0; padding: 0;;
    background: #f5f5ff;
}
a {
    color: #261a3b;
}
a:visited {
    color: #261a3b;
}
p {
    margin: 0 0 15px 0;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0px 0 15px 0;
}
h1 {
    margin-top: 40px;
}
#container {
    position: relative;
}
#jump_to, #jump_page {
    background: white;
    -webkit-box-shadow: 0 0 25px #777; -moz-box-shadow: 0 0 25px #777;
    -webkit-border-bottom-left-radius: 5px; -moz-border-radius-bottomleft: 5px;
    font: 10px Arial;
    text-transform: uppercase;
    cursor: pointer;
    text-align: right;
}
#jump_to, #jump_wrapper {
    position: fixed;
    right: 0; top: 0;
    padding: 5px 10px;
}
#jump_wrapper {
    padding: 0;
    display: none;
}
#jump_to:hover #jump_wrapper {
    display: block;
}
#jump_page {
    padding: 5px 0 3px;
    margin: 0 0 25px 25px;
}
#jump_page .source {
    display: block;
    padding: 5px 10px;
    text-decoration: none;
    border-top: 1px solid #eee;
}
#jump_page .source:hover {
    background: #f5f5ff;
}
#jump_page .source:first-child {
}

#main {
    padding: 0;
    display: flex;
    flex-direction: column;
}
.block  {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-items: stretch;
}
.docs {
    border-right: 1px solid #e5e5ee;
    padding: 5px 25px 0;
    background: white;
}
.code {
    padding: 5px 15px 0;
}

.block:hover .docs, .block:hover .code{
    background: #fffbdd;
}

.pilwrap {
    position: relative;
}
.pilcrow {
    font: 12px Arial;
    text-decoration: none;
    color: #454545;
    position: absolute;
    top: 3px; left: -20px;
    padding: 1px 2px;
    opacity: 0;
    -webkit-transition: opacity 0.2s linear;
}
.docs:hover .pilcrow {
    opacity: 1;
}
code {
    padding: 14px 15px 16px 0;
}
pre, tt, code {
    font-size: 14px;
    line-height: 18px;
    font-family: "Source Code Pro", Menlo, Monaco, Consolas, "Lucida Console", monospace;
    margin: 0; padding: 0;
}


/*---------------------- Syntax Highlighting -----------------------------*/
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }

/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

/*Theme*/

code[class*="language-"]{
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
}

pre[class*="language-"].line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
	position: relative;
	white-space: inherit;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
    left: -3.8em;
	width: 4em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 0;
    margin: 0;
    overflow-x: auto;
    overflow-y: hidden;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


/* Floating and sizes */

/* Custom, iPhone Retina */ 
@media only screen and (max-width : 959px) {

    body {
        font-size: 15px;
        line-height: 22px;
    }

    pre, tt, code {
        font-size: 14px;
        line-height: 18px;
    }
    
    .block {
        flex-direction: column;
    }

    .block .docs {
        padding-top: 25px; 
    }

    .block .docs p:last-child {
        margin-bottom: 5px; 
    }

    .code  {
        padding-left: 0;
    }
}

/* Medium Devices, Desktops */
@media only screen and (min-width : 960px) {

    
    body {
        font-size: 14px;
        line-height: 22px;
    }

    pre, tt, code {
        font-size: 12px;
        line-height: 16px;
    }

    .docs {
        width: 300px;
    }
    
    .docs:last-child {
        flex-grow: 1;
    }

    .code {
        flex-grow: 1;
        width: calc(100vw - 550px);
    }

}

/* Large Devices, Wide Screens */
@media only screen and (min-width : 1200px) {
    
    body {
        font-size: 15px;
        line-height: 22px;
    }

    pre, tt, code {
        font-size: 14px;
        line-height: 18px;
    }

    .docs {
        width: 500px;
    }

    .code {
        flex-grow: 1;
        width: calc(100vw - 600px);
    }
}


/* Large Devices, Wide Screens */
@media only screen and (min-width : 1400px) {
    
    body {
        font-size: 15px;
        line-height: 22px;
    }

    pre, tt, code {
        font-size: 14px;
        line-height: 18px;
    }

    .docs {
        width: 600px;
    }

    .code {
        flex-grow: 1;
        width: 700px;
    }
}
</style><script>var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var o=/\blang(?:uage)?-([\w-]+)\b/i,t=0,O=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof s?new s(e.type,O.util.encode(e.content),e.alias):"Array"===O.util.type(e)?e.map(O.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,a){var t=O.util.type(e);switch(a=a||{},t){case"Object":if(a[O.util.objId(e)])return a[O.util.objId(e)];var n={};for(var r in a[O.util.objId(e)]=n,e)e.hasOwnProperty(r)&&(n[r]=O.util.clone(e[r],a));return n;case"Array":if(a[O.util.objId(e)])return a[O.util.objId(e)];n=[];return a[O.util.objId(e)]=n,e.forEach(function(e,t){n[t]=O.util.clone(e,a)}),n}return e}},languages:{extend:function(e,t){var a=O.util.clone(O.languages[e]);for(var n in t)a[n]=t[n];return a},insertBefore:function(a,e,t,n){var r=(n=n||O.languages)[a];if(2==arguments.length){for(var i in t=e)t.hasOwnProperty(i)&&(r[i]=t[i]);return r}var s={};for(var l in r)if(r.hasOwnProperty(l)){if(l==e)for(var i in t)t.hasOwnProperty(i)&&(s[i]=t[i]);s[l]=r[l]}return O.languages.DFS(O.languages,function(e,t){t===n[a]&&e!=a&&(this[e]=s)}),n[a]=s},DFS:function(e,t,a,n){for(var r in n=n||{},e)e.hasOwnProperty(r)&&(t.call(e,r,e[r],a||r),"Object"!==O.util.type(e[r])||n[O.util.objId(e[r])]?"Array"!==O.util.type(e[r])||n[O.util.objId(e[r])]||(n[O.util.objId(e[r])]=!0,O.languages.DFS(e[r],t,r,n)):(n[O.util.objId(e[r])]=!0,O.languages.DFS(e[r],t,null,n)))}},plugins:{},highlightAll:function(e,t){O.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,a){var n={callback:a,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};O.hooks.run("before-highlightall",n);for(var r,i=n.elements||e.querySelectorAll(n.selector),s=0;r=i[s++];)O.highlightElement(r,!0===t,n.callback)},highlightElement:function(e,t,a){for(var n,r,i=e;i&&!o.test(i.className);)i=i.parentNode;i&&(n=(i.className.match(o)||[,""])[1].toLowerCase(),r=O.languages[n]),e.className=e.className.replace(o,"").replace(/\s+/g," ")+" language-"+n,e.parentNode&&(i=e.parentNode,/pre/i.test(i.nodeName)&&(i.className=i.className.replace(o,"").replace(/\s+/g," ")+" language-"+n));var s={element:e,language:n,grammar:r,code:e.textContent};if(O.hooks.run("before-sanity-check",s),!s.code||!s.grammar)return s.code&&(O.hooks.run("before-highlight",s),s.element.textContent=s.code,O.hooks.run("after-highlight",s)),void O.hooks.run("complete",s);if(O.hooks.run("before-highlight",s),t&&_self.Worker){var l=new Worker(O.filename);l.onmessage=function(e){s.highlightedCode=e.data,O.hooks.run("before-insert",s),s.element.innerHTML=s.highlightedCode,a&&a.call(s.element),O.hooks.run("after-highlight",s),O.hooks.run("complete",s)},l.postMessage(JSON.stringify({language:s.language,code:s.code,immediateClose:!0}))}else s.highlightedCode=O.highlight(s.code,s.grammar,s.language),O.hooks.run("before-insert",s),s.element.innerHTML=s.highlightedCode,a&&a.call(e),O.hooks.run("after-highlight",s),O.hooks.run("complete",s)},highlight:function(e,t,a){var n={code:e,grammar:t,language:a};return O.hooks.run("before-tokenize",n),n.tokens=O.tokenize(n.code,n.grammar),O.hooks.run("after-tokenize",n),s.stringify(O.util.encode(n.tokens),n.language)},matchGrammar:function(e,t,a,n,r,i,s){var l=O.Token;for(var o in a)if(a.hasOwnProperty(o)&&a[o]){if(o==s)return;var u=a[o];u="Array"===O.util.type(u)?u:[u];for(var g=0;g<u.length;++g){var c=u[g],d=c.inside,p=!!c.lookbehind,m=!!c.greedy,h=0,f=c.alias;if(m&&!c.pattern.global){var y=c.pattern.toString().match(/[imuy]*$/)[0];c.pattern=RegExp(c.pattern.source,y+"g")}c=c.pattern||c;for(var b=n,k=r;b<t.length;k+=t[b].length,++b){var v=t[b];if(t.length>e.length)return;if(!(v instanceof l)){if(m&&b!=t.length-1){if(c.lastIndex=k,!(S=c.exec(e)))break;for(var P=S.index+(p?S[1].length:0),w=S.index+S[0].length,F=b,x=k,A=t.length;F<A&&(x<w||!t[F].type&&!t[F-1].greedy);++F)(x+=t[F].length)<=P&&(++b,k=x);if(t[b]instanceof l)continue;j=F-b,v=e.slice(k,x),S.index-=k}else{c.lastIndex=0;var S=c.exec(v),j=1}if(S){p&&(h=S[1]?S[1].length:0);w=(P=S.index+h)+(S=S[0].slice(h)).length;var _=v.slice(0,P),N=v.slice(w),C=[b,j];_&&(++b,k+=_.length,C.push(_));var E=new l(o,d?O.tokenize(S,d):S,f,S,m);if(C.push(E),N&&C.push(N),Array.prototype.splice.apply(t,C),1!=j&&O.matchGrammar(e,t,a,b,k,!0,o),i)break}else if(i)break}}}}},tokenize:function(e,t,a){var n=[e],r=t.rest;if(r){for(var i in r)t[i]=r[i];delete t.rest}return O.matchGrammar(e,n,t,0,0,!1),n},hooks:{all:{},add:function(e,t){var a=O.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=O.hooks.all[e];if(a&&a.length)for(var n,r=0;n=a[r++];)n(t)}}},s=O.Token=function(e,t,a,n,r){this.type=e,this.content=t,this.alias=a,this.length=0|(n||"").length,this.greedy=!!r};if(s.stringify=function(t,a,e){if("string"==typeof t)return t;if("Array"===O.util.type(t))return t.map(function(e){return s.stringify(e,a,t)}).join("");var n={type:t.type,content:s.stringify(t.content,a,e),tag:"span",classes:["token",t.type],attributes:{},language:a,parent:e};if(t.alias){var r="Array"===O.util.type(t.alias)?t.alias:[t.alias];Array.prototype.push.apply(n.classes,r)}O.hooks.run("wrap",n);var i=Object.keys(n.attributes).map(function(e){return e+'="'+(n.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+n.tag+' class="'+n.classes.join(" ")+'"'+(i?" "+i:"")+">"+n.content+"</"+n.tag+">"},!_self.document)return _self.addEventListener&&(O.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,n=t.code,r=t.immediateClose;_self.postMessage(O.highlight(n,O.languages[a],a)),r&&_self.close()},!1)),_self.Prism;var e=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return e&&(O.filename=e.src,O.manual||e.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(O.highlightAll):window.setTimeout(O.highlightAll,16):document.addEventListener("DOMContentLoaded",O.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism),Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:/<!DOCTYPE[\s\S]+?>/i,cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/(^|[^\\])["']/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup,Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/\B!important\b/i,function:/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag)),Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/[a-z0-9_]+(?=\()/i,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/},Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,number:/\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,function:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,operator:/-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,alias:"function"},constant:/\b[A-Z][A-Z\d_]*\b/}),Prism.languages.insertBefore("javascript","string",{"template-string":{pattern:/`(?:\\[\s\S]|\${[^}]+}|[^\\`])*`/,greedy:!0,inside:{interpolation:{pattern:/\${[^}]+}/,inside:{"interpolation-punctuation":{pattern:/^\${|}$/,alias:"punctuation"},rest:null}},string:/[\s\S]+/}}}),Prism.languages.javascript["template-string"].inside.interpolation.inside.rest=Prism.languages.javascript,Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:"language-javascript",greedy:!0}}),Prism.languages.js=Prism.languages.javascript,"undefined"!=typeof self&&self.Prism&&self.document&&document.querySelector&&(self.Prism.fileHighlight=function(){var o={js:"javascript",py:"python",rb:"ruby",ps1:"powershell",psm1:"powershell",sh:"bash",bat:"batch",h:"c",tex:"latex"};Array.prototype.slice.call(document.querySelectorAll("pre[data-src]")).forEach(function(e){for(var t,a=e.getAttribute("data-src"),n=e,r=/\blang(?:uage)?-([\w-]+)\b/i;n&&!r.test(n.className);)n=n.parentNode;if(n&&(t=(e.className.match(r)||[,""])[1]),!t){var i=(a.match(/\.(\w+)$/)||[,""])[1];t=o[i]||i}var s=document.createElement("code");s.className="language-"+t,e.textContent="",s.textContent="Loading…",e.appendChild(s);var l=new XMLHttpRequest;l.open("GET",a,!0),l.onreadystatechange=function(){4==l.readyState&&(l.status<400&&l.responseText?(s.textContent=l.responseText,Prism.highlightElement(s)):400<=l.status?s.textContent="✖ Error "+l.status+" while fetching file: "+l.statusText:s.textContent="✖ Error: File does not exist or is empty")},l.send(null)}),Prism.plugins.toolbar&&Prism.plugins.toolbar.registerButton("download-file",function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-src")&&t.hasAttribute("data-download-link")){var a=t.getAttribute("data-src"),n=document.createElement("a");return n.textContent=t.getAttribute("data-download-link-label")||"Download",n.setAttribute("download",""),n.href=a,n}})},document.addEventListener("DOMContentLoaded",self.Prism.fileHighlight));Prism.languages.rust={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:[{pattern:/b?r(#*)"(?:\\.|(?!"\1)[^\\\r\n])*"\1/,greedy:!0},{pattern:/b?"(?:\\.|[^\\\r\n"])*"/,greedy:!0}],"char":{pattern:/b?'(?:\\(?:x[0-7][\da-fA-F]|u{(?:[\da-fA-F]_*){1,6}|.)|[^\\\r\n\t'])'/,alias:"string"},"lifetime-annotation":{pattern:/'[^\s>']+/,alias:"symbol"},keyword:/\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,attribute:{pattern:/#!?\[.+?\]/,greedy:!0,alias:"attr-name"},"function":[/\w+(?=\s*\()/,/\w+!(?=\s*\(|\[)/],"macro-rules":{pattern:/\w+!/,alias:"function"},number:/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\b/,"closure-params":{pattern:/\|[^|]*\|(?=\s*[{-])/,inside:{punctuation:/[|:,]/,operator:/[&*]/}},punctuation:/[{}[\];(),:]|\.+|->/,operator:/[-+*\/%!^]=?|=[=>]?|@|&[&=]?|\|[|=]?|<<?=?|>>?=?/};(function () {

	if (typeof self === 'undefined' || !self.Prism || !self.document) {
		return;
	}

	/**
	 * Plugin name which is used as a class name for <pre> which is activating the plugin
	 * @type {String}
	 */
	var PLUGIN_NAME = 'line-numbers';

	/**
	 * Regular expression used for determining line breaks
	 * @type {RegExp}
	 */
	var NEW_LINE_EXP = /\n(?!$)/g;

	/**
	 * Resizes line numbers spans according to height of line of code
	 * @param {Element} element <pre> element
	 */
	var _resizeElement = function (element) {
		var codeStyles = getStyles(element);
		var whiteSpace = codeStyles['white-space'];

		if (whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line') {
			var codeElement = element.querySelector('code');
			var lineNumbersWrapper = element.querySelector('.line-numbers-rows');
			var lineNumberSizer = element.querySelector('.line-numbers-sizer');
			var codeLines = codeElement.textContent.split(NEW_LINE_EXP);

			if (!lineNumberSizer) {
				lineNumberSizer = document.createElement('span');
				lineNumberSizer.className = 'line-numbers-sizer';

				codeElement.appendChild(lineNumberSizer);
			}

			lineNumberSizer.style.display = 'block';

			codeLines.forEach(function (line, lineNumber) {
				lineNumberSizer.textContent = line || '\n';
				var lineSize = lineNumberSizer.getBoundingClientRect().height;
				lineNumbersWrapper.children[lineNumber].style.height = lineSize + 'px';
			});

			lineNumberSizer.textContent = '';
			lineNumberSizer.style.display = 'none';
		}
	};

	/**
	 * Returns style declarations for the element
	 * @param {Element} element
	 */
	var getStyles = function (element) {
		if (!element) {
			return null;
		}

		return window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);
	};

	window.addEventListener('resize', function () {
		Array.prototype.forEach.call(document.querySelectorAll('pre.' + PLUGIN_NAME), _resizeElement);
	});

	Prism.hooks.add('complete', function (env) {
		if (!env.code) {
			return;
		}

		var code = env.element;
		var pre = code.parentNode;

		// works only for <code> wrapped inside <pre> (not inline)
		if (!pre || !/pre/i.test(pre.nodeName)) {
			return;
		}

		// Abort if line numbers already exists
		if (code.querySelector('.line-numbers-rows')) {
			return;
		}

		var addLineNumbers = false;
		var lineNumbersRegex = /(?:^|\s)line-numbers(?:\s|$)/;

		for (var element = code; element; element = element.parentNode) {
			if (lineNumbersRegex.test(element.className)) {
				addLineNumbers = true;
				break;
			}
		}

		// only add line numbers if <code> or one of its ancestors has the `line-numbers` class
		if (!addLineNumbers) {
			return;
		}

		// Remove the class 'line-numbers' from the <code>
		code.className = code.className.replace(lineNumbersRegex, ' ');
		// Add the class 'line-numbers' to the <pre>
		if (!lineNumbersRegex.test(pre.className)) {
			pre.className += ' line-numbers';
		}

		var match = env.code.match(NEW_LINE_EXP);
		var linesNum = match ? match.length + 1 : 1;
		var lineNumbersWrapper;

		var lines = new Array(linesNum + 1).join('<span></span>');

		lineNumbersWrapper = document.createElement('span');
		lineNumbersWrapper.setAttribute('aria-hidden', 'true');
		lineNumbersWrapper.className = 'line-numbers-rows';
		lineNumbersWrapper.innerHTML = lines;

		if (pre.hasAttribute('data-start')) {
			pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
		}

		env.element.appendChild(lineNumbersWrapper);

		_resizeElement(pre);

		Prism.hooks.run('line-numbers', env);
	});

	Prism.hooks.add('line-numbers', function (env) {
		env.plugins = env.plugins || {};
		env.plugins.lineNumbers = true;
	});

	/**
	 * Global exports
	 */
	Prism.plugins.lineNumbers = {
		/**
		 * Get node for provided line number
		 * @param {Element} element pre element
		 * @param {Number} number line number
		 * @return {Element|undefined}
		 */
		getLine: function (element, number) {
			if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
				return;
			}

			var lineNumberRows = element.querySelector('.line-numbers-rows');
			var lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;
			var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);

			if (number < lineNumberStart) {
				number = lineNumberStart;
			}
			if (number > lineNumberEnd) {
				number = lineNumberEnd;
			}

			var lineIndex = number - lineNumberStart;

			return lineNumberRows.children[lineIndex];
		}
	};

}());</script></head><body><div id="container"><div id="main"><div class="block">
    <div id="section-0" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-0">&#182;</a>
        </div><p><strong><code>offchaincb.rs</code></strong> (in <code>runtime/src</code>)</p>
    </div>
</div><div class="block">
    <div id="section-1" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-1">&#182;</a>
        </div><h1>Offchain Worker Callback Example</h1>
<p>This is a minimal example module to show case how the runtime can and should
interact with an offchain worker asynchronously.</p>
<p>This example plays simple ping-pong with authenticated off-chain workers:
Once a signed transaction to <code>ping</code> is submitted, the runtime store <code>Ping</code> request.
After every block the offchain worker is triggered. If it sees a <code>Ping</code> request
in the current block, it reacts by sending a signed transaction to call
<code>pong</code>.  When <code>pong</code> is called, it emits an <code>Ack</code> event so it easy to track
with existing UIs whether the Ping-Pong-Ack happened.</p>
<p>However, because the <code>pong</code> contains trusted information (the <code>nonce</code>) the runtime
can't verify by itself - the key reason why we have the offchain worker in the
first place - we can't allow just anyone to call <code>pong</code>. Instead the runtime has a
local list of <code>authorities</code>-keys that allowed to evoke <code>pong</code>. In this simple example
this list can only be extended via a root call (e.g. <code>sudo</code>). In practice more
complex management models and session based key rotations should be considered, but
this is out of the scope of this example</p>
    </div>
</div><div class="block">
    <div id="section-2" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-2">&#182;</a>
        </div><p>Ensure we're <code>no_std</code> when compiling for Wasm. Otherwise our <code>Vec</code> and operations
on it will fail with <code>invalid</code>.</p>
    </div>
    <div class="code">
<pre data-start="21"><code class="language-rust line-numbers">#![cfg_attr(not(feature = "std"), no_std)]
</code></pre>
    </div>
</div><div class="block">
    <div id="section-3" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-3">&#182;</a>
        </div><p>We have to import a few things</p>
    </div>
    <div class="code">
<pre data-start="25"><code class="language-rust line-numbers">use rstd::prelude::*;
use app_crypto::RuntimeAppPublic;
use support::{decl_module, decl_event, decl_storage, StorageValue, dispatch::Result};
use system::{ensure_signed, ensure_root};
use system::offchain::SubmitSignedTransaction;
use codec::{Encode, Decode};
</code></pre>
    </div>
</div><div class="block">
    <div id="section-4" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-4">&#182;</a>
        </div><p>Our local KeyType.</p>
<p>For security reasons the offchain worker doesn't have direct access to the keys
but only to app-specific subkeys, which are defined and grouped by their <code>KeyTypeId</code>.
We define it here as <code>ofcb</code> (for <code>offchain callback</code>). Yours should be specific to
the module you are actually building.</p>
    </div>
    <div class="code">
<pre data-start="33"><code class="language-rust line-numbers">pub const KEY_TYPE: app_crypto::KeyTypeId = app_crypto::KeyTypeId(*b"ofcb");
</code></pre>
    </div>
</div><div class="block">
    <div id="section-5" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-5">&#182;</a>
        </div><p>The module's main configuration trait.</p>
    </div>
    <div class="code">
<pre data-start="41"><code class="language-rust line-numbers">pub trait Trait: system::Trait  {</code></pre>
    </div>
</div><div class="block">
    <div id="section-6" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-6">&#182;</a>
        </div><p>The regular events type, we use to emit the <code>Ack</code></p>
    </div>
    <div class="code">
<pre data-start="43"><code class="language-rust line-numbers">	type Event:From&lt;Event&lt;Self>> + Into&lt;&lt;Self as system::Trait>::Event>;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-7" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-7">&#182;</a>
        </div><p>A dispatchable call type. We need to define it for the offchain worker to
reference the <code>pong</code> function it wants to call.</p>
    </div>
    <div class="code">
<pre data-start="46"><code class="language-rust line-numbers">	type Call: From&lt;Call&lt;Self>>;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-8" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-8">&#182;</a>
        </div><p>Let's define the helper we use to create signed transactions with</p>
    </div>
    <div class="code">
<pre data-start="50"><code class="language-rust line-numbers">	type SubmitTransaction: SubmitSignedTransaction&lt;Self, &lt;Self as Trait>::Call>;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-9" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-9">&#182;</a>
        </div><p>The local keytype</p>
    </div>
    <div class="code">
<pre data-start="53"><code class="language-rust line-numbers">	type KeyType: RuntimeAppPublic + From&lt;Self::AccountId> + Into&lt;Self::AccountId> + Clone;
}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-10" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-10">&#182;</a>
        </div><p>The type of requests we can send to the offchain worker</p>
    </div>
    <div class="code">
<pre data-start="57"><code class="language-rust line-numbers">#[derive(Encode, Decode)]
pub enum OffchainRequest&lt;T: system::Trait> {</code></pre>
    </div>
</div><div class="block">
    <div id="section-11" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-11">&#182;</a>
        </div><p>If an authorised offchain worker sees this ping, it shall respond with a <code>pong</code> call</p>
    </div>
    <div class="code">
<pre data-start="60"><code class="language-rust line-numbers">	Ping(u8,  &lt;T as system::Trait>::AccountId)
}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-12" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-12">&#182;</a>
        </div><p>We use the regular Event type to sent the final ack for the nonce</p>
    </div>
    <div class="code">
<pre data-start="64"><code class="language-rust line-numbers">decl_event!(
	pub enum Event&lt;T> where AccountId = &lt;T as system::Trait>::AccountId {</code></pre>
    </div>
</div><div class="block">
    <div id="section-13" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-13">&#182;</a>
        </div><p>When we received a Pong, we also Ack it.</p>
    </div>
    <div class="code">
<pre data-start="67"><code class="language-rust line-numbers">		Ack(u8, AccountId),
	}
);

</code></pre>
    </div>
</div><div class="block">
    <div id="section-14" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-14">&#182;</a>
        </div><p>We use storage in two important ways here:</p>
<ol>
<li>we have a local list of <code>OcRequests</code>, which are cleared at the beginning
and then collected throughout a block</li>
<li>we store the list of authorities, from whom we accept <code>pong</code> calls.</li>
</ol>
    </div>
    <div class="code">
<pre data-start="73"><code class="language-rust line-numbers">decl_storage! {
	trait Store for Module&lt;T: Trait> as OffchainCb {</code></pre>
    </div>
</div><div class="block">
    <div id="section-15" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-15">&#182;</a>
        </div><p>Requests made within this block execution</p>
    </div>
    <div class="code">
<pre data-start="79"><code class="language-rust line-numbers">		OcRequests: Vec&lt;OffchainRequest&lt;T>>;</code></pre>
    </div>
</div><div class="block">
    <div id="section-16" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-16">&#182;</a>
        </div><p>The current set of keys that may submit pongs</p>
    </div>
    <div class="code">
<pre data-start="81"><code class="language-rust line-numbers">		Authorities get(authorities): Vec&lt;T::AccountId>;
	}
}

</code></pre>
    </div>
</div><div class="block">
    <div id="section-17" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-17">&#182;</a>
        </div><p>The actual Module definition. This is where we create the callable functions</p>
    </div>
    <div class="code">
<pre data-start="87"><code class="language-rust line-numbers">decl_module! {
	pub struct Module&lt;T: Trait> for enum Call where origin: T::Origin {</code></pre>
    </div>
</div><div class="block">
    <div id="section-18" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-18">&#182;</a>
        </div><p>Initializing events</p>
    </div>
    <div class="code">
<pre data-start="90"><code class="language-rust line-numbers">		fn deposit_event() = default;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-19" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-19">&#182;</a>
        </div><p>Clean the state on initialisation of a block</p>
    </div>
    <div class="code">
<pre data-start="93"><code class="language-rust line-numbers">		fn on_initialize(_now: T::BlockNumber) {</code></pre>
    </div>
</div><div class="block">
    <div id="section-20" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-20">&#182;</a>
        </div><p>At the beginning of each block execution, system triggers all
<code>on_initialize</code> functions, which allows us to set up some temprorary
state or - like in this case - clean up other states</p>
    </div>
    <div class="code">
<pre data-start="95"><code class="language-rust line-numbers">			&lt;Self as Store>::OcRequests::kill();
		}

</code></pre>
    </div>
</div><div class="block">
    <div id="section-21" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-21">&#182;</a>
        </div><p>The entry point function: storing a <code>Ping</code> offchain request with the given <code>nonce</code>.</p>
    </div>
    <div class="code">
<pre data-start="102"><code class="language-rust line-numbers">		pub fn ping(origin, nonce: u8) -> Result {</code></pre>
    </div>
</div><div class="block">
    <div id="section-22" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-22">&#182;</a>
        </div><p>It first ensures the function was signed, then it store the <code>Ping</code> request
with our nonce and author. Finally it results with <code>Ok</code>.</p>
    </div>
    <div class="code">
<pre data-start="104"><code class="language-rust line-numbers">			let who = ensure_signed(origin)?;
			
			&lt;Self as Store>::OcRequests::mutate(|v| v.push(OffchainRequest::Ping(nonce, who)));
			Ok(())
		}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-23" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-23">&#182;</a>
        </div><p>Called from the offchain worker to respond to a ping</p>
    </div>
    <div class="code">
<pre data-start="112"><code class="language-rust line-numbers">		pub fn pong(origin, nonce: u8) -> Result {</code></pre>
    </div>
</div><div class="block">
    <div id="section-24" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-24">&#182;</a>
        </div><p>We don't allow anyone to <code>pong</code> but only those authorised in the <code>authorities</code>
set at this point. Therefore after ensuring this is singed, we check whether
that given author is allowed to <code>pong</code> is. If so, we emit the <code>Ack</code> event,
otherwise we've just consumed their fee.</p>
    </div>
    <div class="code">
<pre data-start="114"><code class="language-rust line-numbers">			let author = ensure_signed(origin)?;

			if Self::is_authority(&author) {
				Self::deposit_event(RawEvent::Ack(nonce, author));
			}

			Ok(())
		}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-25" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-25">&#182;</a>
        </div><p>Runs after every block within the context and current state of said block.</p>
    </div>
    <div class="code">
<pre data-start="127"><code class="language-rust line-numbers">		fn offchain_worker(_now: T::BlockNumber) {</code></pre>
    </div>
</div><div class="block">
    <div id="section-26" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-26">&#182;</a>
        </div><p>As <code>pongs</code> are only accepted by authorities, we only run this code,
if a valid local key is found, we could submit them with.</p>
    </div>
    <div class="code">
<pre data-start="129"><code class="language-rust line-numbers">			if let Some(key) = Self::authority_id() {
				Self::offchain(&key);
			}
		}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-27" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-27">&#182;</a>
        </div><p>Simple authority management: add a new authority to the set of keys that
are allowed to respond with <code>pong</code>.</p>
    </div>
    <div class="code">
<pre data-start="136"><code class="language-rust line-numbers">		pub fn add_authority(origin, who: T::AccountId) -> Result {</code></pre>
    </div>
</div><div class="block">
    <div id="section-28" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-28">&#182;</a>
        </div><p>In practice this should be a bit cleverer, but for this example it is enough
that this is protected by a root-call (e.g. through governance like <code>sudo</code>).</p>
    </div>
    <div class="code">
<pre data-start="139"><code class="language-rust line-numbers">			let _me = ensure_root(origin)?;

			if !Self::is_authority(&who){
				&lt;Authorities&lt;T>>::mutate(|l| l.push(who));
			}

			Ok(())
		}
	}
}

</code></pre>
    </div>
</div><div class="block">
    <div id="section-29" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-29">&#182;</a>
        </div><p>We've moved the  helper functions outside of the main decleration for briefety.</p>
    </div>
    <div class="code">
<pre data-start="153"><code class="language-rust line-numbers">impl&lt;T: Trait> Module&lt;T> {
</code></pre>
    </div>
</div><div class="block">
    <div id="section-30" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-30">&#182;</a>
        </div><p>The main entry point, called with account we are supposed to sign with</p>
    </div>
    <div class="code">
<pre data-start="156"><code class="language-rust line-numbers">	fn offchain(key: &T::AccountId) {</code></pre>
    </div>
</div><div class="block">
    <div id="section-31" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-31">&#182;</a>
        </div><p>Let's iterat through the locally stored requests and react to them.
At the moment, only knows of one request to respond to: <code>ping</code>.
Once a ping is found, we respond by calling <code>pong</code> as a transaction
signed with the given key.
This would be the place, where a regular offchain worker would go off
and do its actual thing before reponding async at a later point in time.</p>
<p>Note, that even though this is run directly on the same block, as we are
creating a new transaction, this will only react <em>in the following</em> block.</p>
    </div>
    <div class="code">
<pre data-start="158"><code class="language-rust line-numbers">		for e in &lt;Self as Store>::OcRequests::get() {
			match e {
				OffchainRequest::Ping(nonce, _who) => {
					Self::respond(key, nonce)
				}</code></pre>
    </div>
</div><div class="block">
    <div id="section-32" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-32">&#182;</a>
        </div><p>there would be potential other calls</p>
    </div>
    <div class="code">
<pre data-start="172"><code class="language-rust line-numbers">			}
		}
	}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-33" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-33">&#182;</a>
        </div><p>Respondong to as the given account to a given nonce by calling <code>pong</code> as a
newly signed and submitted trasnaction</p>
    </div>
    <div class="code">
<pre data-start="177"><code class="language-rust line-numbers">	fn respond(key: &T::AccountId, nonce: u8) {
		runtime_io::print_utf8(b"Received ping, sending pong");
		let call = Call::pong(nonce);
		let _ = T::SubmitTransaction::sign_and_submit(call, key.clone().into());
	}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-34" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-34">&#182;</a>
        </div><p>Helper that confirms whether the given <code>AccountId</code> can sign <code>pong</code> transactions</p>
    </div>
    <div class="code">
<pre data-start="185"><code class="language-rust line-numbers">	fn is_authority(who: &T::AccountId) -> bool {
		Self::authorities().into_iter().find(|i| i == who).is_some()
	}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-35" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-35">&#182;</a>
        </div><p>Find a local <code>AccountId</code> we can sign with, that is allowed to <code>pong</code></p>
    </div>
    <div class="code">
<pre data-start="190"><code class="language-rust line-numbers">	fn authority_id() -> Option&lt;T::AccountId> {</code></pre>
    </div>
</div><div class="block">
    <div id="section-36" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-36">&#182;</a>
        </div><p>Find all local keys accessible to this app through the localised KeyType.
Then go through all keys currently stored on chain and check them against
the list of local keys until a match is found, otherwise return <code>None</code>.</p>
    </div>
    <div class="code">
<pre data-start="192"><code class="language-rust line-numbers">		let local_keys = T::KeyType::all().iter().map(
				|i| (*i).clone().into()
			).collect::&lt;Vec&lt;T::AccountId>>();

		Self::authorities().into_iter().find_map(|authority| {
			if local_keys.contains(&authority) {
				Some(authority)
			} else {
				None
			}
		})
	}
}</code></pre>
    </div>
</div><div class="block">
    <div id="section-37" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-37">&#182;</a>
        </div><p><strong><code>lib.rs</code></strong> (in <code>runtime/src</code>)</p>
    </div>
</div><div class="block">
    <div id="section-38" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-38">&#182;</a>
        </div><p>Based off the regular Substrate Node Template runtime.</p>
    </div>
    <div class="code">
<pre data-start="1"><code class="language-rust line-numbers">
#![cfg_attr(not(feature = "std"), no_std)]
#![recursion_limit="256"]

#[cfg(feature = "std")]
include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));

use rstd::prelude::*;
use primitives::{OpaqueMetadata, crypto::key_types};
use sr_primitives::{
	ApplyResult, transaction_validity::TransactionValidity, generic, create_runtime_str,
	impl_opaque_keys, AnySignature
};
use sr_primitives::traits::{NumberFor, BlakeTwo256, Block as BlockT, DigestFor, StaticLookup,
							Verify, ConvertInto, SaturatedConversion};
use sr_primitives::weights::Weight;
use babe::{AuthorityId as BabeId};
use grandpa::{AuthorityId as GrandpaId, AuthorityWeight as GrandpaWeight};
use grandpa::fg_primitives::{self, ScheduledChange};
use client::{
	block_builder::api::{CheckInherentsResult, InherentData, self as block_builder_api},
	runtime_api as client_api, impl_runtime_apis
};
use version::RuntimeVersion;
#[cfg(feature = "std")]
use version::NativeVersion;

#[cfg(any(feature = "std", test))]
pub use sr_primitives::BuildStorage;
pub use timestamp::Call as TimestampCall;
pub use balances::Call as BalancesCall;
pub use sr_primitives::{Permill, Perbill};
pub use support::{StorageValue, construct_runtime, parameter_types};</code></pre>
    </div>
</div><div class="block">
    <div id="section-39" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-39">&#182;</a>
        </div><p>Additionally, we need <code>system</code> here</p>
    </div>
    <div class="code">
<pre data-start="35"><code class="language-rust line-numbers">use system::offchain::TransactionSubmitter;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-40" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-40">&#182;</a>
        </div><p>Everything else is as usual</p>
    </div>
    <div class="code">
<pre data-start="38"><code class="language-rust line-numbers">pub type BlockNumber = u32;
pub type Signature = AnySignature;
pub type AccountId = &lt;Signature as Verify>::Signer;
pub type AccountIndex = u32;
pub type Balance = u128;
pub type Index = u32;
pub type Hash = primitives::H256;
pub type DigestItem = generic::DigestItem&lt;Hash>;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-41" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-41">&#182;</a>
        </div><p>We import our own module here.`</p>
    </div>
    <div class="code">
<pre data-start="48"><code class="language-rust line-numbers">mod offchaincb;
pub mod opaque {
	use super::*;

	pub use sr_primitives::OpaqueExtrinsic as UncheckedExtrinsic;

	pub type Header = generic::Header&lt;BlockNumber, BlakeTwo256>;
	pub type Block = generic::Block&lt;Header, UncheckedExtrinsic>;
	pub type BlockId = generic::BlockId&lt;Block>;

	pub type SessionHandlers = (Grandpa, Babe);

	impl_opaque_keys! {
		pub struct SessionKeys {
			#[id(key_types::GRANDPA)]
			pub grandpa: GrandpaId,
			#[id(key_types::BABE)]
			pub babe: BabeId,
		}
	}
}

pub const VERSION: RuntimeVersion = RuntimeVersion {
	spec_name: create_runtime_str!("offchain-cb"),
	impl_name: create_runtime_str!("offchain-cb"),
	authoring_version: 3,
	spec_version: 4,
	impl_version: 4,
	apis: RUNTIME_API_VERSIONS,
};

pub const MILLISECS_PER_BLOCK: u64 = 6000;
pub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;
pub const EPOCH_DURATION_IN_BLOCKS: u32 = 10 * MINUTES;

pub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);
pub const HOURS: BlockNumber = MINUTES * 60;
pub const DAYS: BlockNumber = HOURS * 24;

pub const PRIMARY_PROBABILITY: (u64, u64) = (1, 4);

#[cfg(feature = "std")]
pub fn native_version() -> NativeVersion {
	NativeVersion {
		runtime_version: VERSION,
		can_author_with: Default::default(),
	}
}

parameter_types! {
	pub const BlockHashCount: BlockNumber = 250;
	pub const MaximumBlockWeight: Weight = 1_000_000;
	pub const AvailableBlockRatio: Perbill = Perbill::from_percent(75);
	pub const MaximumBlockLength: u32 = 5 * 1024 * 1024;
	pub const Version: RuntimeVersion = VERSION;
}

impl system::Trait for Runtime {
	type AccountId = AccountId;
	type Call = Call;
	type Lookup = Indices;
	type Index = Index;
	type BlockNumber = BlockNumber;
	type Hash = Hash;
	type Hashing = BlakeTwo256;
	type Header = generic::Header&lt;BlockNumber, BlakeTwo256>;
	type Event = Event;
	type WeightMultiplierUpdate = ();
	type Origin = Origin;
	type BlockHashCount = BlockHashCount;
	type MaximumBlockWeight = MaximumBlockWeight;
	type MaximumBlockLength = MaximumBlockLength;
	type AvailableBlockRatio = AvailableBlockRatio;
	type Version = Version;
}

parameter_types! {
	pub const EpochDuration: u64 = EPOCH_DURATION_IN_BLOCKS as u64;
	pub const ExpectedBlockTime: u64 = MILLISECS_PER_BLOCK;
}

impl babe::Trait for Runtime {
	type EpochDuration = EpochDuration;
	type ExpectedBlockTime = ExpectedBlockTime;
}

impl grandpa::Trait for Runtime {
	type Event = Event;
}

impl indices::Trait for Runtime {
	type AccountIndex = u32;
	type ResolveHint = indices::SimpleResolveHint&lt;Self::AccountId, Self::AccountIndex>;
	type IsDeadAccount = Balances;
	type Event = Event;
}

parameter_types! {
	pub const MinimumPeriod: u64 = 5000;
}

impl timestamp::Trait for Runtime {
	type Moment = u64;
	type OnTimestampSet = Babe;
	type MinimumPeriod = MinimumPeriod;
}

parameter_types! {
	pub const ExistentialDeposit: u128 = 500;
	pub const TransferFee: u128 = 0;
	pub const CreationFee: u128 = 0;
	pub const TransactionBaseFee: u128 = 0;
	pub const TransactionByteFee: u128 = 1;
}

impl balances::Trait for Runtime {
	type Balance = Balance;
	type OnFreeBalanceZero = ();
	type OnNewAccount = Indices;
	type Event = Event;

	type TransactionPayment = ();
	type DustRemoval = ();
	type TransferPayment = ();
	type ExistentialDeposit = ExistentialDeposit;
	type TransferFee = TransferFee;
	type CreationFee = CreationFee;
	type TransactionBaseFee = TransactionBaseFee;
	type TransactionByteFee = TransactionByteFee;
	type WeightToFee = ConvertInto;
}

impl sudo::Trait for Runtime {
	type Event = Event;
	type Proposal = Call;
}

</code></pre>
    </div>
</div><div class="block">
    <div id="section-42" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-42">&#182;</a>
        </div><p>We need to define the AppCrypto for the keys that are authorized
to <code>pong</code></p>
    </div>
    <div class="code">
<pre data-start="187"><code class="language-rust line-numbers">pub mod offchaincb_crypto {
	pub use crate::offchaincb::KEY_TYPE;
	use primitives::sr25519;
	app_crypto::app_crypto!(sr25519, KEY_TYPE);

	impl From&lt;Signature> for super::Signature {
		fn from(a: Signature) -> Self {
			sr25519::Signature::from(a).into()
		}
	}
}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-43" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-43">&#182;</a>
        </div><p>We need to define the Transaction signer for that using the Key definition</p>
    </div>
    <div class="code">
<pre data-start="201"><code class="language-rust line-numbers">type OffchainCbAccount = offchaincb_crypto::Public;
type SubmitTransaction = TransactionSubmitter&lt;OffchainCbAccount, Runtime, UncheckedExtrinsic>;
</code></pre>
    </div>
</div><div class="block">
    <div id="section-44" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-44">&#182;</a>
        </div><p>Now we configure our Trait usng the previously defined primitives</p>
    </div>
    <div class="code">
<pre data-start="205"><code class="language-rust line-numbers">impl offchaincb::Trait for Runtime {
	type Call = Call;
	type Event = Event;
	type SubmitTransaction = SubmitTransaction;
	type KeyType = OffchainCbAccount;
}</code></pre>
    </div>
</div><div class="block">
    <div id="section-45" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-45">&#182;</a>
        </div><p>Lastly we also need to implement the CreateTransaction signer for the runtime</p>
    </div>
    <div class="code">
<pre data-start="212"><code class="language-rust line-numbers">impl system::offchain::CreateTransaction&lt;Runtime, UncheckedExtrinsic> for Runtime {
	type Signature = Signature;

	fn create_transaction&lt;F: system::offchain::Signer&lt;AccountId, Self::Signature>>(
		call: Call,
		account: AccountId,
		index: Index,
	) -> Option&lt;(Call, &lt;UncheckedExtrinsic as sr_primitives::traits::Extrinsic>::SignaturePayload)> {
		let period = 1 &lt;&lt; 8;
		let current_block = System::block_number().saturated_into::&lt;u64>();
		let tip = 0;
		let extra: SignedExtra = (
			system::CheckVersion::&lt;Runtime>::new(),
			system::CheckGenesis::&lt;Runtime>::new(),
			system::CheckEra::&lt;Runtime>::from(generic::Era::mortal(period, current_block)),
			system::CheckNonce::&lt;Runtime>::from(index),
			system::CheckWeight::&lt;Runtime>::new(),
			balances::TakeFees::&lt;Runtime>::from(tip),
		);
		let raw_payload = SignedPayload::new(call, extra).ok()?;
		let signature = F::sign(account.clone(), &raw_payload)?;
		let address = Indices::unlookup(account);
		let (call, extra, _) = raw_payload.deconstruct();
		Some((call, (address, signature, extra)))
	}
}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-46" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-46">&#182;</a>
        </div><p>Then all this can be put together</p>
    </div>
    <div class="code">
<pre data-start="240"><code class="language-rust line-numbers">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		System: system::{Module, Call, Storage, Config, Event},
		Timestamp: timestamp::{Module, Call, Storage, Inherent},
		Babe: babe::{Module, Call, Storage, Config, Inherent(Timestamp)},
		Grandpa: grandpa::{Module, Call, Storage, Config, Event},
		Indices: indices::{default, Config&lt;T>},
		Balances: balances,
		Sudo: sudo,</code></pre>
    </div>
</div><div class="block">
    <div id="section-47" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-47">&#182;</a>
        </div><p>Nothing special here.</p>
    </div>
    <div class="code">
<pre data-start="254"><code class="language-rust line-numbers">		OffchainCB: offchaincb::{Module, Call, Event&lt;T>, Storage},
	}
);

pub type Address = &lt;Indices as StaticLookup>::Source;
pub type Header = generic::Header&lt;BlockNumber, BlakeTwo256>;
pub type Block = generic::Block&lt;Header, UncheckedExtrinsic>;
pub type SignedBlock = generic::SignedBlock&lt;Block>;
pub type BlockId = generic::BlockId&lt;Block>;
pub type SignedExtra = (
	system::CheckVersion&lt;Runtime>,
	system::CheckGenesis&lt;Runtime>,
	system::CheckEra&lt;Runtime>,
	system::CheckNonce&lt;Runtime>,
	system::CheckWeight&lt;Runtime>,
	balances::TakeFees&lt;Runtime>
);
pub type UncheckedExtrinsic = generic::UncheckedExtrinsic&lt;Address, Call, Signature, SignedExtra>;</code></pre>
    </div>
</div><div class="block">
    <div id="section-48" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-48">&#182;</a>
        </div><p>Just that the Signature Signer needs this aditional definition as well</p>
    </div>
    <div class="code">
<pre data-start="273"><code class="language-rust line-numbers">pub type SignedPayload = generic::SignedPayload&lt;Call, SignedExtra>;
pub type CheckedExtrinsic = generic::CheckedExtrinsic&lt;AccountId, Call, SignedExtra>;
pub type Executive = executive::Executive&lt;Runtime, Block, system::ChainContext&lt;Runtime>, Runtime, AllModules>;

impl_runtime_apis! {
	impl client_api::Core&lt;Block> for Runtime {
		fn version() -> RuntimeVersion {
			VERSION
		}

		fn execute_block(block: Block) {
			Executive::execute_block(block)
		}

		fn initialize_block(header: &&lt;Block as BlockT>::Header) {
			Executive::initialize_block(header)
		}
	}

	impl client_api::Metadata&lt;Block> for Runtime {
		fn metadata() -> OpaqueMetadata {
			Runtime::metadata().into()
		}
	}

	impl block_builder_api::BlockBuilder&lt;Block> for Runtime {
		fn apply_extrinsic(extrinsic: &lt;Block as BlockT>::Extrinsic) -> ApplyResult {
			Executive::apply_extrinsic(extrinsic)
		}

		fn finalize_block() -> &lt;Block as BlockT>::Header {
			Executive::finalize_block()
		}

		fn inherent_extrinsics(data: InherentData) -> Vec&lt;&lt;Block as BlockT>::Extrinsic> {
			data.create_extrinsics()
		}

		fn check_inherents(block: Block, data: InherentData) -> CheckInherentsResult {
			data.check_extrinsics(&block)
		}

		fn random_seed() -> &lt;Block as BlockT>::Hash {
			System::random_seed()
		}
	}

	impl client_api::TaggedTransactionQueue&lt;Block> for Runtime {
		fn validate_transaction(tx: &lt;Block as BlockT>::Extrinsic) -> TransactionValidity {
			Executive::validate_transaction(tx)
		}
	}
</code></pre>
    </div>
</div><div class="block">
    <div id="section-49" class="docs">
        <div class="pilwrap">
            <a class="pilcrow" href="#section-49">&#182;</a>
        </div><p>This comes with new templates now, if you don't have it, you have to implement
this trait in order for the Offchain Worker to be triggerd.</p>
    </div>
    <div class="code">
<pre data-start="327"><code class="language-rust line-numbers">	impl offchain_primitives::OffchainWorkerApi&lt;Block> for Runtime {
		fn offchain_worker(number: NumberFor&lt;Block>) {
			Executive::offchain_worker(number)
		}
	}

	impl fg_primitives::GrandpaApi&lt;Block> for Runtime {
		fn grandpa_pending_change(digest: &DigestFor&lt;Block>)
			-> Option&lt;ScheduledChange&lt;NumberFor&lt;Block>>>
		{
			Grandpa::pending_change(digest)
		}

		fn grandpa_forced_change(digest: &DigestFor&lt;Block>)
			-> Option&lt;(NumberFor&lt;Block>, ScheduledChange&lt;NumberFor&lt;Block>>)>
		{
			Grandpa::forced_change(digest)
		}

		fn grandpa_authorities() -> Vec&lt;(GrandpaId, GrandpaWeight)> {
			Grandpa::grandpa_authorities()
		}
	}

	impl babe_primitives::BabeApi&lt;Block> for Runtime {
		fn startup_data() -> babe_primitives::BabeConfiguration {
			babe_primitives::BabeConfiguration {
				median_required_blocks: 1000,
				slot_duration: Babe::slot_duration(),
				c: PRIMARY_PROBABILITY,
			}
		}

		fn epoch() -> babe_primitives::Epoch {
			babe_primitives::Epoch {
				start_slot: Babe::epoch_start_slot(),
				authorities: Babe::authorities(),
				epoch_index: Babe::epoch_index(),
				randomness: Babe::randomness(),
				duration: EpochDuration::get(),
				secondary_slots: Babe::secondary_slots().0,
			}
		}
	}

	impl substrate_session::SessionKeys&lt;Block> for Runtime {
		fn generate_session_keys(seed: Option&lt;Vec&lt;u8>>) -> Vec&lt;u8> {
			let seed = seed.as_ref().map(|s| rstd::str::from_utf8(&s).expect("Seed is an utf8 string"));
			opaque::SessionKeys::generate(seed)
		}
	}
}</code></pre>
    </div>
</div></div></div></body></html>